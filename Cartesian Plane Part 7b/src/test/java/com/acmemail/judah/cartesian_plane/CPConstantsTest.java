package com.acmemail.judah.cartesian_plane;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;

import java.awt.Color;
import java.awt.Font;
import java.lang.reflect.Field;

import org.junit.jupiter.api.Test;

class CPConstantsTest
{
    @Test
    public void test_APP_PROPERTIES_NAME()
    {
        String  fieldName   = "APP_PROPERTIES_NAME";
        try
        {
            Field   propField   = CPConstants.class.getField( fieldName );
            assertNotNull( propField );
        }
        catch ( NoSuchFieldException | SecurityException exc )
        {
            String  msg = "Field " + fieldName + " not found";
            fail( msg, exc );
        }
    }
    
    @Test
    public void testPNMapToDV()
    {
        // Verify that all variables with names that end in _PN
        // match a corresponding variable with a name that ends in _DV.
        for ( Field pnField : CPConstants.class.getFields() )
        {
            String  fieldName   = pnField.getName();
            if ( fieldName.endsWith( "_PN" ) )
            {
                // derive the name of the associated DV field...
                // ... get the name of the PN field
                int     pNameLen    = fieldName.length();
                assertTrue( pNameLen > 3 );
                // ... get the start of the PN field name (without the _PN)
                String  pNamePrefix = fieldName.substring( 0, pNameLen - 3 );
                // ... construct the name of the DV field
                String  dvName      = pNamePrefix + "_DV";
                try
                {
                    // If the field is there the test succeeds; if it 
                    // throws NoSuchFieldException it fails. 
                    CPConstants.class.getField( dvName );
                }
                catch ( NoSuchFieldException exc )
                {
                    StringBuilder   bldr    = new StringBuilder();
                    bldr.append( "For property name field " )
                        .append( fieldName )
                        .append( " no default value field (" )
                        .append( dvName )
                        .append( ") found" );
                    fail( bldr.toString() );
                }
            }
        }
    }
    
    @Test
    public void testDVMapToPN()
    {
        // Verify that have generated _PN fields for all the
        // original _DV fields.
        for ( Field pnField : CPConstants.class.getFields() )
        {
            String  fieldName   = pnField.getName();
            if ( fieldName.endsWith( "_DV" ) )
            {
                // derive the name of the associated PN field...
                // ... get the name of the DV field
                int     dvNameLen       = fieldName.length();
                assertTrue( dvNameLen > 3 );
                // ... get the start of the PN field name (without the _PN)
                String  dvNamePrefix    = fieldName.substring( 0, dvNameLen - 3 );
                // ... construct the name of the DV field
                String  pName           = dvNamePrefix + "_PN";
                try
                {
                    // If the field is there the test succeeds; if it 
                    // throws NoSuchFieldException it fails. 
                    CPConstants.class.getField( pName );
                }
                catch ( NoSuchFieldException exc )
                {
                    StringBuilder   bldr    = new StringBuilder();
                    bldr.append( "For default value name field " )
                        .append( fieldName )
                        .append( " no default property name field (" )
                        .append( pName )
                        .append( ") found" );
                    fail( bldr.toString() );
                }
            }
        }
    }
    
    @Test
    public void testCPConstants()
    {
        // This is just to get code coverage on the constructor
        // generated by the compiler.
        new CPConstants();
    }
    
    @Test
    void testAsInt()
    {
        int[]   testVals    = { -5, -1, 0, 1, 5 };
        for ( int val : testVals )
        {
            int actVal  = CPConstants.asInt( "" + val );
            assertEquals( val, actVal );
        }
        
        // Go-wrong path: verify that NumberFormatException is thrown
        // if a non-numeric string is passed.
        Class<NumberFormatException>    clazz   = NumberFormatException.class;
        assertThrows( clazz, () -> CPConstants.asInt( "five" ) );
    }

    @Test
    void testAsFloat()
    {
        float[] testVals    = { -5.1f, -1.1f, 0, 1.1f, 5.1f };
        for ( float val : testVals )
        {
            float   actVal  = CPConstants.asFloat( "" + val );
            assertEquals( val, actVal, .001 );
        }
        
        // Go-wrong path: verify that NumberFormatException is thrown
        // if a non-numeric string is passed.
        Class<NumberFormatException>    clazz   = NumberFormatException.class;
        assertThrows( clazz, () -> CPConstants.asInt( "five" ) );
    }

    @Test
    void testAsBoolean()
    {
        String[]    strVals = 
            { "True", "true", "TRUE", "False", "false", "FALSE", "a" };
        boolean[]   expVals =
            {  true,   true,   true,   false,   false,   false, false  };
        for ( int inx = 0 ; inx < strVals.length ; ++inx )
        {
            boolean actVal  = CPConstants.asBoolean( strVals[inx] );
            boolean expVal  = expVals[inx];
            assertEquals( actVal, expVal );
        }
    }

    @Test
    void testAsColor()
    {
        int[]       iVals   =
        {
            0xff00ff,
            0x00cc00,
            0x0e0e0e
        };
        for ( int iVal : iVals )
        {
            String  strVal1 = "0x" + Integer.toHexString( iVal );
            String  strVal2 = "#" + Integer.toHexString( iVal );
            String  strVal3 = "" + iVal;
            Color   actVal1 = CPConstants.asColor( strVal1 );
            Color   actVal2 = CPConstants.asColor( strVal2 );
            Color   actVal3 = CPConstants.asColor( strVal3 );
            
            // Compare the original integer value to the value of the
            // Color expressed as an int. The Color value includes
            // the alpha component (bits 28-31, 0xFF000000) which must
            // be turned off before performing the comparison
            testColorAsInt( iVal, actVal1 );
            testColorAsInt( iVal, actVal2 );
            testColorAsInt( iVal, actVal3 );
        }
    }

    @Test
    void testAsFontStyle()
    {
        int pValUpper   = CPConstants.asFontStyle( "PLAIN" );
        assertEquals( Font.PLAIN, pValUpper );
        int bValUpper   = CPConstants.asFontStyle( "BOLD" );
        assertEquals( Font.BOLD, bValUpper );
        int iValUpper   = CPConstants.asFontStyle( "ITALIC" );
        assertEquals( Font.ITALIC, iValUpper );
        
        int pValLower   = CPConstants.asFontStyle( "plain" );
        assertEquals( Font.PLAIN, pValLower );
        int bValLower   = CPConstants.asFontStyle( "bold" );
        assertEquals( Font.BOLD, bValLower );
        int iValLower   = CPConstants.asFontStyle( "italic" );
        assertEquals( Font.ITALIC, iValLower );
        
        // Test go-wrong path
        Class<IllegalArgumentException> clazz   =
            IllegalArgumentException.class;
        assertThrows( clazz, () -> CPConstants.asFontStyle( "INVALID" ) );
    }
    
    /**
     * Compares an integer value to a Color converted to an integer.
     * The alpha bits in the Color value are suppressed
     * prior to performing the comparison.
     * 
     * @param expVal    given integer value
     * @param color     given Color value
     */
    private static void testColorAsInt( int expVal, Color color )
    {
        int rgb     = color.getRGB();
        int actVal  = rgb & ~0xFF000000;
        assertEquals( expVal, actVal );
    }
}
